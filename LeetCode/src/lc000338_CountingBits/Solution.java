package lc000338_CountingBits;

import java.util.Arrays;

public class Solution {

	public Solution() {}

	//思路：觀察bit數量，找出規律
	//因為任何數做<<運算都等於乘2的意思，意思是乘二後等於二進位會多一位bit 0在末尾，但bit 1數量不變，以此為思路出發
	//2的次方均為1(10, 100, 1000, ...)，也可以以此為基底計算出其它bit數量，
	//例子：[28]:11100 => 10000+1100 => [16]+[12]

	//0:0				0 => [0]+0 => [0]+0
	//1:1				1 => [1]+0 => [0]+1
	//2:10				1 => [2]+0 => [1]+0	(1<<1+00)
	//3:11				2 => [2]+1 => [1]+1	(10+01)

	//4:100				1 => [4]+0 => [2]+0	(10<<1+00)
	//5:101				2 => [4]+1 => [2]+1	(100+001)
	//6:110				2 => [4]+1 => [3]+0	(11<<1+000)
	//7:111				3 => [4]+2 => [3]+1	(110+001)

	//8:1000			1 => [8]+0 => [4]+0
	//9:1001			2 => [8]+1 => [4]+1
	//10:1010			2 => [8]+1 => [5]+0
	//11:1011			3 => [8]+2 => [5]+1

	//12:1100			2 => [8]+1 => [6]+0
	//13:1101			3 => [8]+2 => [6]+1
	//14:1110			3 => [8]+2 => [7]+0
	//15:1111			4 => [8]+3 => [7]+1

	//16:10000			1 => [16]+0 => [8]+0
	//17:10001			2 => [16]+1 => [8]+1
	//18:10010			2 => [16]+1 => [9]+0
	//19:10011			3 => [16]+2 => [9]+1

	//20:10100			2 => [16]+1 => [10]+0
	//21:10101			3 => [16]+2 => [10]+1
	//22:10110			3 => [16]+2 => [11]+0
	//23:10111			4 => [16]+3 => [11]+1

	//24:11000			2 => [16]+1 => [12]+0
	//25:11001			3 => [16]+2 => [12]+1
	//26:11010			3 => [16]+2 => [13]+0
	//27:11011			4 => [16]+3 => [13]+1

	//28:11100			3 => [16]+2 => [14]+0 => [16]+[12]
	//29:11101			4 => [16]+3 => [14]+1 => [16]+[13]
	//30:11110			4 => [16]+3 => [15]+0 => [16]+[14]
	//31:11111			5 => [16]+4 => [15]+1 => [16]+[15]

	//32:100000			1
	//33:100001			2
	//34:100010			2
	//35:100011			3

	//36:100100			2
	//37:100101			3
	//38:100110			3
	//39:100111			4

	public int[] countBits(int n) {
		//思路：利用>>運算得到i/2的商數，再用&運算求餘數(0或1)，直觀邏輯就是利用[13]：1101 => 1100+0001 => [12]+1 =>[12>>1]+(1101&0001)
		int[] result = new int[n+1];
		for(int i=1; i<=n; i++) {
			result[i] = result[i>>1]+(i&1);
		}
		System.out.println(Arrays.toString(result));
		return result;
	}

	public int[] countBits2(int n) {
		//思路：改為常規四則運算邏輯，好理解
		int[] result = new int[n+1];
		for(int i=1; i<=n; i++) {
			result[i] = result[i/2] + i%2;	//result[i] = result[i/2] + result[i%2];
		}
		System.out.println(Arrays.toString(result));
		return result;
	}

	public int[] countBits3(int n) {
		//思路：上一個四則運算的邏輯改為判斷；如果整除那就跟除2後那個數一樣數量(110、1100概念)，如果無法整除那前一個肯定可以被2整除，那就是前一個再加1
		//例子：[31]詳細運算邏輯是[30]+1 => [15*2]+1 => [15]+1 => [7*2+1]+1 => [7]+1+1 => [3]+1+1+1 => [2]+1+1+1+1 => [1]+1+1+1+1 => 1+1+1+1+1
		int[] result = new int[n+1];
		for(int i=1; i<=n; i++) {
			result[i] = i%2==0 ? result[i/2] : result[i-1] +1;
		}
		System.out.println(Arrays.toString(result));
		return result;
	}

}
